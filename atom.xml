<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Supltz</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Supltz.github.io/"/>
  <updated>2020-05-24T15:18:43.981Z</updated>
  <id>http://Supltz.github.io/</id>
  
  <author>
    <name>Supltz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础</title>
    <link href="http://Supltz.github.io/2020/05/24/java.html/"/>
    <id>http://Supltz.github.io/2020/05/24/java.html/</id>
    <published>2020-05-24T14:26:30.000Z</published>
    <updated>2020-05-24T15:18:43.981Z</updated>
    
    <content type="html"><![CDATA[<p>读java核心技术卷一的一些笔记。<br><a id="more"></a><br>这本书大概需要掌握的有600页吧。。还是蛮多的。</p><h2 id="1-75页"><a href="#1-75页" class="headerlink" title="1~75页"></a>1~75页</h2><p><em>这周花了3~4个小时快速过了75页，前面都是一些基础，很简单，但是还是有值得记录的一些地方把。</em></p><pre><code class="bash">java里没有头文件，指针运算，结构，联合，操作符重载，虚基类等。（其实这些我大多数也不知道是啥。。。）java与C++的主要不同点在于多重继承，在java中，取而代之的是更简单的接口的概念。java提供了跟丰富的自省功能（这一点将在第五章讨论）虚拟机有一个选项，可以将执行最频繁的字节码序列转换成机器码，这一过程称为即时编译。（这里涉及到编译型和解释型的概念）字符串采用标准的Unicode格式存储。字节码可以在运行时动态的转换成CPU机器码。C#和Java有很多相似之处javac 是编译器将.java编译成.class文件，java启动java虚拟机执行字节码。关键字public，private 叫做访问修饰符，控制访问级别的。java应用程序的全部内容都必须放置在类中。类名可以用骆驼命名法：CamelCasejava虚拟机总是从指定类中的main方法开始执行。main方法必须声明为public，必须是静态的。System.out.println()System.out.print()System.out.printf()    printf中可以使用%d,%s等替换变量java是一种强类型语言（对比弱类型语言python）java中没有无符号形式的int,byte和long,short类型。java中的舍入误差：2.0-1.1=0.899999999999当心注释中的\ujava中False不等于0，True不等于1java中并不区分声明和定义类常量定义在ain的外部用final定义常量&amp;&amp;和||按照短路方式来求值得，&amp;和|需要两个都满足，java支持三元操作符如：x&lt;y?x:yjava中得切片也是左闭右开的比较记得用.equals()方法，不要用==空和null的区别StringBuilder只能单线程，StringBuffer可以多线程Scanner input=new Scanner(System.in)   Scanner类在java.util.下，System.in和Scanner是两个关联的对象String in=input.nextLine()       获取控制台输入nextInt(),nextDouble()之类的Scanner in=new Scanner(Path.of(&quot;&quot;),Standard(Charsets.UTF_8))  读文件PrintWriter out=new PrintWriter(&quot;&quot;,Standard(Charsets.UTF_8))  写文件String dir=System.getProperty(&quot;user.dir&quot;)   获取工作目录java不允许嵌套的块作用域中重定义变量</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读java核心技术卷一的一些笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-技术" scheme="http://Supltz.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="-java" scheme="http://Supltz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://Supltz.github.io/2020/05/23/linux.html/"/>
    <id>http://Supltz.github.io/2020/05/23/linux.html/</id>
    <published>2020-05-23T14:20:30.000Z</published>
    <updated>2020-05-24T14:31:49.955Z</updated>
    
    <content type="html"><![CDATA[<p>有时间还得系统得学一学linux。。。。<br><a id="more"></a></p><h2 id="最近向虚拟机中传文件时遇到得几个坑"><a href="#最近向虚拟机中传文件时遇到得几个坑" class="headerlink" title="最近向虚拟机中传文件时遇到得几个坑"></a>最近向虚拟机中传文件时遇到得几个坑</h2><h3 id="实现共享文件夹的步骤"><a href="#实现共享文件夹的步骤" class="headerlink" title="实现共享文件夹的步骤"></a>实现共享文件夹的步骤</h3><ol><li>安装vmware-tools，虚拟机中必须要先安装vm-tools才能传文件。<br>命令：<pre><code class="bash">sudo apt-get install open-vm-tools</code></pre></li><li><p>然后在vmware虚拟机的设置中启动共享文件夹（这个网上教程都还挺完整的）</p></li><li><p>共享过来的文件夹在虚拟机的/mnt/hgfs路径下。<br>问题来了：这个路径只有root权限才可以访问，而且我的mnt下没有hgfs这个文件夹。<br>首先进入root权限：</p><pre><code class="bash">sudo su</code></pre><p>然后cd进mnt里：</p><pre><code class="bash">cd /mnt</code></pre><p>自己创建一个文件夹：</p><pre><code class="bash">mkdir hgfs</code></pre><p>(创建了之后还是空的啥都没有)<br>这时候先执行：</p><pre><code class="bash">sudo vmware-hgfsclient</code></pre><p>会返回你要共享的那个文件夹（说明共享文件夹创建成功）<br>然后执行：</p><pre><code class="bash">mount -t vmhgfs .host:/ /mnt/hgfs (我这里报错：No such device)</code></pre><p>如果没用报错就成功了，如果报错了，就执行：</p><pre><code class="bash">vmhgfs-fuse .host:/ /mnt/hgfs</code></pre></li></ol><p>这时候/mnt/hgfs路径下应该有那个共享文件夹了！</p><p>还没结束，别忘了/mnt/hgfs这个路径只有root权限才能访问，不方便操作，最好把共享文件夹的内容复制到普通权限用户的文件夹来：<br>命令:</p><pre><code class="bash">cp -R /mnt/hgfs/test(这个test是自己命名的)/* /home/supltz（自己的用户名）/test/</code></pre><p>记：<br>root权限下的/home和普通用户下的/home是不一样的！！！！<br>即普通用户下的/home/test在root权限下是/home/supltz（自己的用户名）/test</p><h3 id="一些常用的linux命令"><a href="#一些常用的linux命令" class="headerlink" title="一些常用的linux命令"></a>一些常用的linux命令</h3><pre><code class="bash">chown -R 用户名 路径    ----修改文件夹权限gedit /etc/profile     ----文本编辑器（以环境变量为例）source /etc/profile    ----立即执行修改tar zxvf 文件名         ----解压文件</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时间还得系统得学一学linux。。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-技术" scheme="http://Supltz.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="-linux" scheme="http://Supltz.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>机器学习Kaggle实战</title>
    <link href="http://Supltz.github.io/2020/04/27/ML.html/"/>
    <id>http://Supltz.github.io/2020/04/27/ML.html/</id>
    <published>2020-04-27T13:47:45.000Z</published>
    <updated>2020-04-30T08:52:49.167Z</updated>
    
    <content type="html"><![CDATA[<p>Kaggle入门(Titanic案例)<br><a id="more"></a></p><p>最近跑了Kaggle中的Titanic竞赛</p><p>参考了一些博客<br>附上链接：</p><ul><li><a href="https://www.jianshu.com/p/e79a8c41cb1a" target="_blank" rel="noopener">https://www.jianshu.com/p/e79a8c41cb1a</a></li><li><a href="https://www.kesci.com/home/project/5bfe39b3954d6e0010681cd1" target="_blank" rel="noopener">https://www.kesci.com/home/project/5bfe39b3954d6e0010681cd1</a></li></ul><p>博客内容大多数都差不多，参考了一下总体思路，在这些博客的基础上做了优化<br>比如：</p><ol><li>对Name属性进行了挖掘</li><li>用seaborn绘图更直观</li><li>做了模型融合（但是效果一般）</li><li>进行了参数调优</li></ol><p><em>Titanic简介：</em></p><p>根据年龄，性别或船上乘客舱位等特征来预测给定乘客的生存或死亡。</p><p>结果：本文在公共排行榜上最高获得了0.79904的准确性得分，排名前11％。</p><p>Talk is cheap,show me the code!</p><p>方便图片显示，用html的使绘图集中(主要还是因为jupyter notebook)</p><pre><code class="python">from IPython.core.display import HTMLHTML(&quot;&quot;&quot;&lt;style&gt;.output_png {    display: table-cell;    text-align: center;    vertical-align: middle;}&lt;/style&gt;&quot;&quot;&quot;);</code></pre><p>导入基本的库</p><pre><code class="python">%matplotlib inlineimport warningswarnings.filterwarnings(&#39;ignore&#39;)warnings.filterwarnings(&#39;ignore&#39;, category=DeprecationWarning)import pandas as pdpd.options.display.max_columns = 100from matplotlib import pyplot as pltimport numpy as npimport seaborn as snsimport pylab as plotparams = {    &#39;axes.labelsize&#39;: &quot;large&quot;,    &#39;xtick.labelsize&#39;: &#39;x-large&#39;,    &#39;legend.fontsize&#39;: 20,    &#39;figure.dpi&#39;: 150,    &#39;figure.figsize&#39;: [25, 7]}plot.rcParams.update(params)</code></pre><p>先加载训练集。</p><pre><code class="python">data = pd.read_csv(&#39;train.csv&#39;)</code></pre><h1 id="一、Data-Insights"><a href="#一、Data-Insights" class="headerlink" title="一、Data Insights"></a>一、Data Insights</h1><p> 这是第一部分也是最重要的一部分，很大程度的决定了后面的Feature Engineering 和 Modeling 应该怎么做。<br> 只有足够了解数据才能做出好的效果！！</p><pre><code class="python">print (data.shape)</code></pre><pre><code>(891, 12)</code></pre><p>训练集的shape</p><ul><li>891 rows</li><li>12 columns</li></ul><p>先简单的查看一下数据</p><pre><code class="python">data.head()</code></pre><details><summary>点击查看</summary><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>PassengerId</th><th>Survived</th><th>Pclass</th><th>Name</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>0</td><td>3</td><td>Braund, Mr. Owen Harris</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>NaN</td><td>S</td></tr><tr><th>1</th><td>2</td><td>1</td><td>1</td><td>Cumings, Mrs. John Bradley (Florence Briggs Th…</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>C</td></tr><tr><th>2</th><td>3</td><td>1</td><td>3</td><td>Heikkinen, Miss. Laina</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>NaN</td><td>S</td></tr><tr><th>3</th><td>4</td><td>1</td><td>1</td><td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>C123</td><td>S</td></tr><tr><th>4</th><td>5</td><td>0</td><td>3</td><td>Allen, Mr. William Henry</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>NaN</td><td>S</td></tr></tbody></table></details><p>Survived列是<strong>目标变量</strong>。如果Suvived = 1，则该乘客幸免，否则死亡。是我们要预测的变量。</p><p>其他变量描述了乘客。它们是<strong>特征</strong>。</p><ul><li>PassengerId：和给船上每个旅客的编号</li><li>Pclass：乘客舱。它具有三个可能的值：1,2,3（第一，第二和第三等）</li><li>Name:名字</li><li>Sex:性别</li><li>Age:年龄</li><li>SibSp：与乘客同行的兄弟姐妹和配偶的数量</li><li>Parch：与乘客同行的父母和子女的数量</li><li>Ticket:票号</li><li>Fare:票价</li><li>Cabin:舱号</li><li>Embarked:人们登上泰坦尼克号的三个可能区域。三个可能的值S，C，Q</li></ul><p>进一步查看一下数据</p><pre><code class="python">data.describe()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>PassengerId</th><th>Survived</th><th>Pclass</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Fare</th></tr></thead><tbody><tr><th>count</th><td>891.000000</td><td>891.000000</td><td>891.000000</td><td>714.000000</td><td>891.000000</td><td>891.000000</td><td>891.000000</td></tr><tr><th>mean</th><td>446.000000</td><td>0.383838</td><td>2.308642</td><td>29.699118</td><td>0.523008</td><td>0.381594</td><td>32.204208</td></tr><tr><th>std</th><td>257.353842</td><td>0.486592</td><td>0.836071</td><td>14.526497</td><td>1.102743</td><td>0.806057</td><td>49.693429</td></tr><tr><th>min</th><td>1.000000</td><td>0.000000</td><td>1.000000</td><td>0.420000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td></tr><tr><th>25%</th><td>223.500000</td><td>0.000000</td><td>2.000000</td><td>20.125000</td><td>0.000000</td><td>0.000000</td><td>7.910400</td></tr><tr><th>50%</th><td>446.000000</td><td>0.000000</td><td>3.000000</td><td>28.000000</td><td>0.000000</td><td>0.000000</td><td>14.454200</td></tr><tr><th>75%</th><td>668.500000</td><td>1.000000</td><td>3.000000</td><td>38.000000</td><td>1.000000</td><td>0.000000</td><td>31.000000</td></tr><tr><th>max</th><td>891.000000</td><td>1.000000</td><td>3.000000</td><td>80.000000</td><td>8.000000</td><td>6.000000</td><td>512.329200</td></tr></tbody></table></div></details><p>可以看出Age列中缺少177个值。</p><p>在这里先用中位数代替空值，方便后面画图，只用中位数来代替肯定不准确（后面会用具体算法来填充空值）。</p><pre><code class="python">data[&#39;Age&#39;] = data[&#39;Age&#39;].fillna(data[&#39;Age&#39;].median())</code></pre><p>看看处理后的</p><pre><code class="python">data.describe()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>PassengerId</th><th>Survived</th><th>Pclass</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Fare</th></tr></thead><tbody><tr><th>count</th><td>891.000000</td><td>891.000000</td><td>891.000000</td><td>891.000000</td><td>891.000000</td><td>891.000000</td><td>891.000000</td></tr><tr><th>mean</th><td>446.000000</td><td>0.383838</td><td>2.308642</td><td>29.361582</td><td>0.523008</td><td>0.381594</td><td>32.204208</td></tr><tr><th>std</th><td>257.353842</td><td>0.486592</td><td>0.836071</td><td>13.019697</td><td>1.102743</td><td>0.806057</td><td>49.693429</td></tr><tr><th>min</th><td>1.000000</td><td>0.000000</td><td>1.000000</td><td>0.420000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td></tr><tr><th>25%</th><td>223.500000</td><td>0.000000</td><td>2.000000</td><td>22.000000</td><td>0.000000</td><td>0.000000</td><td>7.910400</td></tr><tr><th>50%</th><td>446.000000</td><td>0.000000</td><td>3.000000</td><td>28.000000</td><td>0.000000</td><td>0.000000</td><td>14.454200</td></tr><tr><th>75%</th><td>668.500000</td><td>1.000000</td><td>3.000000</td><td>35.000000</td><td>1.000000</td><td>0.000000</td><td>31.000000</td></tr><tr><th>max</th><td>891.000000</td><td>1.000000</td><td>3.000000</td><td>80.000000</td><td>8.000000</td><td>6.000000</td><td>512.329200</td></tr></tbody></table></div></details><p>我们先来画图，看看能从数据中看出啥</p><p>先看看性别和存活与否的关系。</p><pre><code class="python">data[&#39;Died&#39;] = 1 - data[&#39;Survived&#39;]</code></pre><pre><code class="python">data.groupby(&#39;Sex&#39;).agg(&#39;sum&#39;)[[&#39;Survived&#39;, &#39;Died&#39;]].plot(kind=&#39;bar&#39;, figsize=(25, 7),                                                          stacked=True);</code></pre><p><img src="/2020/04/27/ML.html/article_1/1.png" alt="energy"></p><p>看起来男性更容易遇难，女性更容易获救。</p><p>再看看他们的比例。</p><pre><code class="python">data.groupby(&#39;Sex&#39;).agg(&#39;mean&#39;)[[&#39;Survived&#39;, &#39;Died&#39;]].plot(kind=&#39;bar&#39;, figsize=(25, 7),                                                           stacked=True);</code></pre><p><img src="/2020/04/27/ML.html/article_1/2.png" alt="energy"></p><p><strong>果然在危险的时候，男性总会挺身而出。。。</strong></p><p>再来看看年龄吧</p><pre><code class="python">fig = plt.figure(figsize=(25, 7))sns.violinplot(x=&#39;Sex&#39;, y=&#39;Age&#39;,               hue=&#39;Survived&#39;, data=data,               split=True,               palette={0: &quot;r&quot;, 1: &quot;g&quot;}              );</code></pre><p><img src="/2020/04/27/ML.html/article_1/3.png" alt="energy"></p><p>从提琴图可以看出大概是在<strong>20-40</strong>岁的人存活率比较高</p><p>老人和小孩都跑不动了吗。</p><p>（果然时代都掌握在青年中年人手里</p><p>再来看看票价的影响吧</p><pre><code class="python">figure = plt.figure(figsize=(25, 7))plt.hist([data[data[&#39;Survived&#39;] == 1][&#39;Fare&#39;], data[data[&#39;Survived&#39;] == 0][&#39;Fare&#39;]],         stacked=True, color = [&#39;g&#39;,&#39;r&#39;],         bins = 50, label = [&#39;Survived&#39;,&#39;Dead&#39;])plt.xlabel(&#39;Fare&#39;)plt.ylabel(&#39;Number of passengers&#39;)plt.legend();</code></pre><p><img src="/2020/04/27/ML.html/article_1/4.png" alt="energy"></p><p>看起来，票价高的人容易被获救，一般票价高的人可能社会地位会比较高。</p><p>不过票价高的人还是比较稀少的</p><p>（这就是贫富差距吗</p><p>让我们再综合的看一下年龄和票价</p><pre><code class="python">plt.figure(figsize=(25, 7))ax = plt.subplot()ax.scatter(data[data[&#39;Survived&#39;] == 1][&#39;Age&#39;], data[data[&#39;Survived&#39;] == 1][&#39;Fare&#39;],           c=&#39;green&#39;, s=data[data[&#39;Survived&#39;] == 1][&#39;Fare&#39;])ax.scatter(data[data[&#39;Survived&#39;] == 0][&#39;Age&#39;], data[data[&#39;Survived&#39;] == 0][&#39;Fare&#39;],           c=&#39;red&#39;, s=data[data[&#39;Survived&#39;] == 0][&#39;Fare&#39;]);</code></pre><p><img src="/2020/04/27/ML.html/article_1/5.png" alt="energy"></p><p>圆圈的大小与票价成正比。</p><p>x轴是年龄，y轴是票价。</p><p>我们可以观察到：</p><ol><li>x = 20到x = 45之间的大绿点：成人票价最高</li><li>x = 10到x = 45之间的小红点，可能是船上较低阶层的成年人（穷</li><li>x = 0和x = 7之间的小绿点：这些是被救下来的的小孩</li></ol><p>和常识一样，票价和阶层是成正比的</p><pre><code class="python">ax = plt.subplot()ax.set_ylabel(&#39;Average fare&#39;)data.groupby(&#39;Pclass&#39;).mean()[&#39;Fare&#39;].plot(kind=&#39;bar&#39;, figsize=(25, 7), ax = ax);</code></pre><p><img src="/2020/04/27/ML.html/article_1/6.png" alt="energy"></p><p>看看Embarked对存活率的影响</p><pre><code class="python">fig = plt.figure(figsize=(25, 7))sns.violinplot(x=&#39;Embarked&#39;, y=&#39;Fare&#39;, hue=&#39;Survived&#39;, data=data, split=True, palette={0: &quot;r&quot;, 1: &quot;g&quot;});</code></pre><p><img src="/2020/04/27/ML.html/article_1/7.png" alt="energy"></p><p>Embarked C 的票价似乎范围更广，可以看出，支付最高价的乘客就是幸存者。</p><p>这种也情况发生在登船S上，但是发生在登船Q上的情况较少。</p><h1 id="二-、Feature-engineering"><a href="#二-、Feature-engineering" class="headerlink" title="二  、Feature engineering"></a>二  、Feature engineering</h1><p>在上一部分中，我们对数据进行了探索并发现了一些有趣的相关性。</p><p>在这一部分中，我们将看到如何处理已有的特征，为后面的Modeling做准备。</p><p>为了表达更清楚，将代码分解为单独的函数。</p><p>先写个函数看看函数调用是否成功，方便看到程序走到哪了。</p><pre><code class="python">def status(feature):    print (&#39;Processing&#39;, feature, &#39;: ok&#39;)</code></pre><p><strong>载入数据</strong></p><p>这里我直接把Targets取了出来，然后把训练集和测试集放在了一起</p><p>因为后面做数据处理训练集和测试集都要做，不如先合并了。</p><pre><code class="python">def get_combined_data():    train = pd.read_csv(&#39;train.csv&#39;)    test = pd.read_csv(&#39;test.csv&#39;)    targets = train.Survived    train.drop([&#39;Survived&#39;], 1, inplace=True)    combined = train.append(test)    combined.reset_index(inplace=True)    combined.drop([&#39;index&#39;, &#39;PassengerId&#39;], inplace=True, axis=1)    return combined</code></pre><pre><code class="python">combined = get_combined_data()</code></pre><pre><code class="python">print (combined.shape)</code></pre><pre><code>(1309, 10)</code></pre><p>1309行，其中数据集891行，测试集418行</p><pre><code class="python">combined.head()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Pclass</th><th>Name</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th></tr></thead><tbody><tr><th>0</th><td>3</td><td>Braund, Mr. Owen Harris</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>NaN</td><td>S</td></tr><tr><th>1</th><td>1</td><td>Cumings, Mrs. John Bradley (Florence Briggs Th…</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>C</td></tr><tr><th>2</th><td>3</td><td>Heikkinen, Miss. Laina</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>NaN</td><td>S</td></tr><tr><th>3</th><td>1</td><td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>C123</td><td>S</td></tr><tr><th>4</th><td>3</td><td>Allen, Mr. William Henry</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>NaN</td><td>S</td></tr></tbody></table></div></details><h2 id="Name的处理"><a href="#Name的处理" class="headerlink" title="Name的处理"></a>Name的处理</h2><p>大多数人都以为Name名字这一列没有啥用。</p><p>但是如果仔细观察：</p><ul><li>Braund, Mr. Owen Harris 中的 Mr</li><li>Heikkinen, Miss. Laina  中的Miss<br>等等</li></ul><p>您会注意到每个名称中都有Title！这可以是简单的小姐或太太，但有时也可以是更复杂的东西，例如Master(硕士或者大师)，Duke（爵士）或Dona。在这种情况下，我们可以通过简单地解析名称并提取Title并将其转换为二进制变量来引入有关社会地位的其他信息。</p><p>让我们先看看有哪些标题</p><pre><code class="python">titles = set()for name in data[&#39;Name&#39;]:    titles.add(name.split(&#39;,&#39;)[1].split(&#39;.&#39;)[0].strip())</code></pre><pre><code class="python">print (titles)</code></pre><pre><code>{&#39;Rev&#39;, &#39;Jonkheer&#39;, &#39;Mrs&#39;, &#39;Master&#39;, &#39;Col&#39;, &#39;the Countess&#39;, &#39;Don&#39;, &#39;Mr&#39;, &#39;Major&#39;, &#39;Lady&#39;, &#39;Sir&#39;, &#39;Mlle&#39;, &#39;Capt&#39;, &#39;Dr&#39;, &#39;Miss&#39;, &#39;Mme&#39;, &#39;Ms&#39;}</code></pre><pre><code class="python">Title_Dictionary = {    &quot;Capt&quot;: &quot;Officer&quot;,    &quot;Col&quot;: &quot;Officer&quot;,    &quot;Major&quot;: &quot;Officer&quot;,    &quot;Jonkheer&quot;: &quot;Royalty&quot;,    &quot;Don&quot;: &quot;Royalty&quot;,    &quot;Sir&quot; : &quot;Royalty&quot;,    &quot;Dr&quot;: &quot;Officer&quot;,    &quot;Rev&quot;: &quot;Officer&quot;,    &quot;the Countess&quot;:&quot;Royalty&quot;,    &quot;Mme&quot;: &quot;Mrs&quot;,    &quot;Mlle&quot;: &quot;Miss&quot;,    &quot;Ms&quot;: &quot;Mrs&quot;,    &quot;Mr&quot; : &quot;Mr&quot;,    &quot;Mrs&quot; : &quot;Mrs&quot;,    &quot;Miss&quot; : &quot;Miss&quot;,    &quot;Master&quot; : &quot;Master&quot;,    &quot;Lady&quot; : &quot;Royalty&quot;}def get_titles():    combined[&#39;Title&#39;] = combined[&#39;Name&#39;].map(lambda name:name.split(&#39;,&#39;)[1].split(&#39;.&#39;)[0].strip())    combined[&#39;Title&#39;] = combined.Title.map(Title_Dictionary)    status(&#39;Title&#39;)    return combined</code></pre><p>我们把这些Title都映射到下列的总Title：</p><ul><li>Officer</li><li>Royalty</li><li>Mr</li><li>Mrs</li><li>Miss</li><li>Master</li></ul><pre><code class="python">combined = get_titles()</code></pre><pre><code>Processing Title : ok</code></pre><pre><code class="python">combined.head()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Pclass</th><th>Name</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th><th>Title</th></tr></thead><tbody><tr><th>0</th><td>3</td><td>Braund, Mr. Owen Harris</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>NaN</td><td>S</td><td>Mr</td></tr><tr><th>1</th><td>1</td><td>Cumings, Mrs. John Bradley (Florence Briggs Th…</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>C</td><td>Mrs</td></tr><tr><th>2</th><td>3</td><td>Heikkinen, Miss. Laina</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>NaN</td><td>S</td><td>Miss</td></tr><tr><th>3</th><td>1</td><td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>C123</td><td>S</td><td>Mrs</td></tr><tr><th>4</th><td>3</td><td>Allen, Mr. William Henry</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>NaN</td><td>S</td><td>Mr</td></tr></tbody></table></div></details><p>看看我们总结的Title有没有添加成功（在最后呢</p><pre><code class="python">combined[combined[&#39;Title&#39;].isnull()]</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Pclass</th><th>Name</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th><th>Title</th></tr></thead><tbody><tr><th>1305</th><td>1</td><td>Oliva y Ocana, Dona. Fermina</td><td>female</td><td>39.0</td><td>0</td><td>0</td><td>PC 17758</td><td>108.9</td><td>C105</td><td>C</td><td>NaN</td></tr></tbody></table></div></details><p>发现有一个空值，但是他在测试集影响不大，不管它了。</p><h2 id="Fare的处理"><a href="#Fare的处理" class="headerlink" title="Fare的处理"></a>Fare的处理</h2><p>把之前发现的Fare中的一个缺值用均值代替(其实是后面做随机森林的时候报错才发现的。。。。。这里先把他写到前面</p><pre><code class="python">def process_fares():    global combined    combined.Fare.fillna(combined.iloc[:891].Fare.mean(), inplace=True)    status(&#39;fare&#39;)    return combined</code></pre><pre><code class="python">combined = process_fares()</code></pre><pre><code>Processing fare : ok</code></pre><h2 id="Age的处理"><a href="#Age的处理" class="headerlink" title="Age的处理"></a>Age的处理</h2><p>我们在第一部分中看到训练集Age变量缺少177个值。这是一个很大的数字（约占数据集的13％）。用<br>年龄平均数或中位数年龄代替他们可能不是最好的解决方案，因为年龄可能因乘客的群体和类别而异。</p><p>训练集里丢失的Age</p><pre><code class="python">print (combined.iloc[:891].Age.isnull().sum())</code></pre><pre><code>177</code></pre><p>测试集里丢失的Age</p><pre><code class="python">print (combined.iloc[891:].Age.isnull().sum())</code></pre><pre><code>86</code></pre><p>我这里用用随机森林的方法来补充年龄的缺值</p><p>用’Fare’, ‘Parch’, ‘SibSp’, ‘Pclass’这几个特征来对Age进行预测并填充</p><p>函数如下</p><pre><code class="python">from sklearn.ensemble import RandomForestRegressordef process_age(df):    age_df = df[[&#39;Age&#39;,&#39;Fare&#39;, &#39;Parch&#39;, &#39;SibSp&#39;, &#39;Pclass&#39;]]    known_age = age_df[age_df.Age.notnull()].iloc[:,:].values    unknown_age = age_df[age_df.Age.isnull()].iloc[:,:].values    y = known_age[:, 0]    X = known_age[:, 1:]    rfr = RandomForestRegressor(random_state=0, n_estimators=2000, n_jobs=-1)    rfr.fit(X, y)    predictedAges = rfr.predict(unknown_age[:, 1::])    df.loc[ (df.Age.isnull()), &#39;Age&#39; ] = predictedAges    status(&quot;Age&quot;)    return df</code></pre><pre><code class="python">combined = process_age(combined)</code></pre><pre><code>Processing Age : ok</code></pre><p>这里如果报错：<em>Found array with 0 sample(s) (shape=(0, 4)) while a minimum of 1 is required</em>.</p><p>不是代码的问题，是jupyter notebook变量缓冲的问题</p><p>解决方法：</p><ol><li>重新运行上面两个代码块即可</li><li>刷新或者重新打开，从头开始运行一遍</li><li>直接参考<a href="https://github.com/Supltz/Kaggle_Titanic/blob/master/titanic.py" target="_blank" rel="noopener">titanic.py</a>吧</li></ol><p>我们发现“Embarked”中有两个缺失值，而Cabin中有很多缺失值。稍后我们将回到这些特征。</p><p>我们先把名字做一个one_hot编码</p><pre><code class="python">def process_names():    global combined    combined.drop(&#39;Name&#39;, axis=1, inplace=True)    titles_dummies = pd.get_dummies(combined[&#39;Title&#39;], prefix=&#39;Title&#39;)    combined = pd.concat([combined, titles_dummies], axis=1)    combined.drop(&#39;Title&#39;, axis=1, inplace=True)    status(&#39;names&#39;)    return combined</code></pre><pre><code class="python">combined = process_names()</code></pre><pre><code>Processing names : ok</code></pre><pre><code class="python">combined.head()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Pclass</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th><th>Title_Master</th><th>Title_Miss</th><th>Title_Mr</th><th>Title_Mrs</th><th>Title_Officer</th><th>Title_Royalty</th></tr></thead><tbody><tr><th>0</th><td>3</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>NaN</td><td>S</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><th>1</th><td>1</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>C</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><th>2</th><td>3</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>NaN</td><td>S</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><th>3</th><td>1</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>C123</td><td>S</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><th>4</th><td>3</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>NaN</td><td>S</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div></details><p>one_hot 编码成功</p><h2 id="Embarked的处理"><a href="#Embarked的处理" class="headerlink" title="Embarked的处理"></a>Embarked的处理</h2><pre><code class="python">def process_embarked():    global combined    combined.Embarked.fillna(&#39;S&#39;, inplace=True)    embarked_dummies = pd.get_dummies(combined[&#39;Embarked&#39;], prefix=&#39;Embarked&#39;)    combined = pd.concat([combined, embarked_dummies], axis=1)    combined.drop(&#39;Embarked&#39;, axis=1, inplace=True)    status(&#39;embarked&#39;)    return combined</code></pre><p>对两个缺失的，用众数代替，然后做one_hot</p><pre><code class="python">combined = process_embarked()</code></pre><pre><code>Processing embarked : ok</code></pre><pre><code class="python">combined.head()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Pclass</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Title_Master</th><th>Title_Miss</th><th>Title_Mr</th><th>Title_Mrs</th><th>Title_Officer</th><th>Title_Royalty</th><th>Embarked_C</th><th>Embarked_Q</th><th>Embarked_S</th></tr></thead><tbody><tr><th>0</th><td>3</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>NaN</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><th>1</th><td>1</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><th>2</th><td>3</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>NaN</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><th>3</th><td>1</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>C123</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><th>4</th><td>3</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>NaN</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div></details><h2 id="Cabin的处理"><a href="#Cabin的处理" class="headerlink" title="Cabin的处理"></a>Cabin的处理</h2><pre><code class="python">train_cabin, test_cabin = set(), set()for c in combined.iloc[:891][&#39;Cabin&#39;]:    try:        train_cabin.add(c[0])    except:        train_cabin.add(&#39;U&#39;)for c in combined.iloc[891:][&#39;Cabin&#39;]:    try:        test_cabin.add(c[0])    except:        test_cabin.add(&#39;U&#39;)</code></pre><pre><code class="python">print (train_cabin)</code></pre><pre><code>{&#39;T&#39;, &#39;A&#39;, &#39;G&#39;, &#39;B&#39;, &#39;F&#39;, &#39;C&#39;, &#39;E&#39;, &#39;U&#39;, &#39;D&#39;}</code></pre><pre><code class="python">print (test_cabin)</code></pre><pre><code>{&#39;A&#39;, &#39;G&#39;, &#39;B&#39;, &#39;F&#39;, &#39;E&#39;, &#39;C&#39;, &#39;U&#39;, &#39;D&#39;}</code></pre><p>很好，测试集的cabin在训练集都有。</p><pre><code class="python">def process_cabin():    global combined    combined.Cabin.fillna(&#39;U&#39;, inplace=True)    combined[&#39;Cabin&#39;] = combined[&#39;Cabin&#39;].map(lambda c: c[0])    cabin_dummies = pd.get_dummies(combined[&#39;Cabin&#39;], prefix=&#39;Cabin&#39;)        combined = pd.concat([combined, cabin_dummies], axis=1)    combined.drop(&#39;Cabin&#39;, axis=1, inplace=True)    status(&#39;cabin&#39;)    return combined</code></pre><p>用第一个字母来代表Cabin U来代表Unkown，继续做one_hot 编码</p><pre><code class="python">combined = process_cabin()</code></pre><pre><code>Processing cabin : ok</code></pre><p><strong>到目前这个数据集终于没有缺失的值了！</strong></p><pre><code class="python">combined.head()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Pclass</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Title_Master</th><th>Title_Miss</th><th>Title_Mr</th><th>Title_Mrs</th><th>Title_Officer</th><th>Title_Royalty</th><th>Embarked_C</th><th>Embarked_Q</th><th>Embarked_S</th><th>Cabin_A</th><th>Cabin_B</th><th>Cabin_C</th><th>Cabin_D</th><th>Cabin_E</th><th>Cabin_F</th><th>Cabin_G</th><th>Cabin_T</th><th>Cabin_U</th></tr></thead><tbody><tr><th>0</th><td>3</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><th>1</th><td>1</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><th>2</th><td>3</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><th>3</th><td>1</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><th>4</th><td>3</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div></details><h2 id="Sex的处理"><a href="#Sex的处理" class="headerlink" title="Sex的处理"></a>Sex的处理</h2><pre><code class="python">def process_sex():    global combined    combined[&#39;Sex&#39;] = combined[&#39;Sex&#39;].map({&#39;male&#39;:1, &#39;female&#39;:0})    status(&#39;Sex&#39;)    return combined</code></pre><p>用0，1表示性别。。。。</p><pre><code class="python">combined = process_sex()</code></pre><pre><code>Processing Sex : ok</code></pre><h2 id="Pclass的处理"><a href="#Pclass的处理" class="headerlink" title="Pclass的处理"></a>Pclass的处理</h2><pre><code class="python">def process_pclass():    global combined    pclass_dummies = pd.get_dummies(combined[&#39;Pclass&#39;], prefix=&quot;Pclass&quot;)    combined = pd.concat([combined, pclass_dummies],axis=1)    combined.drop(&#39;Pclass&#39;,axis=1,inplace=True)    status(&#39;Pclass&#39;)    return combined</code></pre><p>还是做one_hot 编码</p><pre><code class="python">combined = process_pclass()</code></pre><pre><code>Processing Pclass : ok</code></pre><h2 id="Ticket的处理"><a href="#Ticket的处理" class="headerlink" title="Ticket的处理"></a>Ticket的处理</h2><p>取出票名的前缀</p><pre><code class="python">def cleanTicket(ticket):    ticket = ticket.replace(&#39;.&#39;, &#39;&#39;)    ticket = ticket.replace(&#39;/&#39;, &#39;&#39;)    ticket = ticket.split()    ticket = map(lambda t : t.strip(), ticket)    ticket = list(filter(lambda t : not t.isdigit(), ticket))    if len(ticket) &gt; 0:        return ticket[0]    else:        return &#39;XXX&#39;</code></pre><pre><code class="python">tickets = set()for t in combined[&#39;Ticket&#39;]:    tickets.add(cleanTicket(t))</code></pre><pre><code class="python">print (len(tickets))</code></pre><pre><code>37</code></pre><pre><code class="python">def process_ticket():    global combined    def cleanTicket(ticket):        ticket = ticket.replace(&#39;.&#39;,&#39;&#39;)        ticket = ticket.replace(&#39;/&#39;,&#39;&#39;)        ticket = ticket.split()        ticket = map(lambda t : t.strip(), ticket)        ticket = list(filter(lambda t : not t.isdigit(), ticket))        if len(ticket) &gt; 0:            return ticket[0]        else:            return &#39;XXX&#39;    # Extracting dummy variables from tickets:    combined[&#39;Ticket&#39;] = combined[&#39;Ticket&#39;].map(cleanTicket)    tickets_dummies = pd.get_dummies(combined[&#39;Ticket&#39;], prefix=&#39;Ticket&#39;)    combined = pd.concat([combined, tickets_dummies], axis=1)    combined.drop(&#39;Ticket&#39;, inplace=True, axis=1)    status(&#39;Ticket&#39;)    return combined</code></pre><pre><code class="python">combined = process_ticket()</code></pre><pre><code>Processing Ticket : ok</code></pre><h2 id="Family的处理"><a href="#Family的处理" class="headerlink" title="Family的处理"></a>Family的处理</h2><p>这里根据家庭的大小来分类</p><p>这是非常合理的</p><p>大家庭聚在一起，因此与独自旅行的人相比，他们更有可能得到救助。</p><pre><code class="python">def process_family():    global combined    combined[&#39;FamilySize&#39;] = combined[&#39;Parch&#39;] + combined[&#39;SibSp&#39;] + 1    combined[&#39;Singleton&#39;] = combined[&#39;FamilySize&#39;].map(lambda s: 1 if s == 1 else 0)    combined[&#39;SmallFamily&#39;] = combined[&#39;FamilySize&#39;].map(lambda s: 1 if 2 &lt;= s &lt;= 4 else 0)    combined[&#39;LargeFamily&#39;] = combined[&#39;FamilySize&#39;].map(lambda s: 1 if 5 &lt;= s else 0)    status(&#39;family&#39;)    return combined</code></pre><p>创建了4个新的特征：</p><ul><li>FamilySize : 家庭大小</li><li>Sigleton : 是不是独自一人</li><li>SmallFamily : 小家庭 2 &lt;= size &lt;= 4</li><li>LargeFamily : 大家庭5 &lt; size</li></ul><pre><code class="python">combined = process_family()</code></pre><pre><code>Processing family : ok</code></pre><pre><code class="python">print (combined.shape)</code></pre><pre><code>(1309, 67)</code></pre><p>这样总共搞出来67列。。。。这也太多了</p><pre><code class="python">combined.head()</code></pre><details><summary>点击查看</summary><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Fare</th><th>Title_Master</th><th>Title_Miss</th><th>Title_Mr</th><th>Title_Mrs</th><th>Title_Officer</th><th>Title_Royalty</th><th>Embarked_C</th><th>Embarked_Q</th><th>Embarked_S</th><th>Cabin_A</th><th>Cabin_B</th><th>Cabin_C</th><th>Cabin_D</th><th>Cabin_E</th><th>Cabin_F</th><th>Cabin_G</th><th>Cabin_T</th><th>Cabin_U</th><th>Pclass_1</th><th>Pclass_2</th><th>Pclass_3</th><th>Ticket_A</th><th>Ticket_A4</th><th>Ticket_A5</th><th>Ticket_AQ3</th><th>Ticket_AQ4</th><th>Ticket_AS</th><th>Ticket_C</th><th>Ticket_CA</th><th>Ticket_CASOTON</th><th>Ticket_FC</th><th>Ticket_FCC</th><th>Ticket_Fa</th><th>Ticket_LINE</th><th>Ticket_LP</th><th>Ticket_PC</th><th>Ticket_PP</th><th>Ticket_PPP</th><th>Ticket_SC</th><th>Ticket_SCA3</th><th>Ticket_SCA4</th><th>Ticket_SCAH</th><th>Ticket_SCOW</th><th>Ticket_SCPARIS</th><th>Ticket_SCParis</th><th>Ticket_SOC</th><th>Ticket_SOP</th><th>Ticket_SOPP</th><th>Ticket_SOTONO2</th><th>Ticket_SOTONOQ</th><th>Ticket_SP</th><th>Ticket_STONO</th><th>Ticket_STONO2</th><th>Ticket_STONOQ</th><th>Ticket_SWPP</th><th>Ticket_WC</th><th>Ticket_WEP</th><th>Ticket_XXX</th><th>FamilySize</th><th>Singleton</th><th>SmallFamily</th><th>LargeFamily</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>22.0</td><td>1</td><td>0</td><td>7.2500</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2</td><td>0</td><td>1</td><td>0</td></tr><tr><th>1</th><td>0</td><td>38.0</td><td>1</td><td>0</td><td>71.2833</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2</td><td>0</td><td>1</td><td>0</td></tr><tr><th>2</th><td>0</td><td>26.0</td><td>0</td><td>0</td><td>7.9250</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><th>3</th><td>0</td><td>35.0</td><td>1</td><td>0</td><td>53.1000</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>0</td></tr><tr><th>4</th><td>1</td><td>35.0</td><td>0</td><td>0</td><td>8.0500</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div></details><h1 id="三、Modeling"><a href="#三、Modeling" class="headerlink" title="三、Modeling"></a>三、Modeling</h1><p>终于来到建模啦</p><p>在这一部分中，我们根据创建的功能使用对乘客的了解，然后建立统计模型。您可以将这种模型视为一个可以处理任何新乘客信息并确定他是否能够幸存的盒子。</p><p>先引入一些建模需要的库</p><pre><code class="python">from sklearn.pipeline import make_pipelinefrom sklearn.ensemble import RandomForestClassifierfrom sklearn.ensemble.gradient_boosting import GradientBoostingClassifierfrom sklearn.feature_selection import SelectKBestfrom sklearn.model_selection import StratifiedKFoldfrom sklearn.model_selection import GridSearchCVfrom sklearn.model_selection import cross_val_scorefrom sklearn.feature_selection import SelectFromModelfrom sklearn.linear_model import LogisticRegression, LogisticRegressionCV</code></pre><p>这里采用 5-fold cross validation</p><pre><code class="python">def compute_score(clf, X, y, scoring=&#39;accuracy&#39;):    xval = cross_val_score(clf, X, y, cv = 5, scoring=scoring)    return np.mean(xval)</code></pre><p>之前数据处理完了，就可以将训练集和测试集分开啦</p><pre><code class="python">def recover_train_test_target():    global combined    targets = pd.read_csv(&#39;train.csv&#39;, usecols=[&#39;Survived&#39;])[&#39;Survived&#39;].values    train = combined.iloc[:891]    test = combined.iloc[891:]    return train, test, targets</code></pre><pre><code class="python">train, test, targets = recover_train_test_target()</code></pre><h2 id="Feature的选择"><a href="#Feature的选择" class="headerlink" title="Feature的选择"></a>Feature的选择</h2><p>到目前为止，我们已经创造了67列。这个数字很大。</p><p>我们必须从中筛选有用的，影响比较大的特征来：</p><ul><li>减少数据之间的冗余</li><li>加快了训练过程</li><li>减少过拟合</li></ul><p>我们可以先来看看哪一些特征是重要的</p><pre><code class="python">clf = RandomForestClassifier(n_estimators=50, max_features=&#39;sqrt&#39;)clf = clf.fit(train, targets)</code></pre><pre><code class="python">features = pd.DataFrame()features[&#39;feature&#39;] = train.columnsfeatures[&#39;importance&#39;] = clf.feature_importances_features.sort_values(by=[&#39;importance&#39;], ascending=True, inplace=True)features.set_index(&#39;feature&#39;, inplace=True)</code></pre><pre><code class="python">features.plot(kind=&#39;barh&#39;, figsize=(25, 25))</code></pre><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1de03588eb8&gt;</code></pre><p><img src="/2020/04/27/ML.html/article_1/8.png" alt="energy"></p><p>我们可以看到Title_Mr, Age, Fare, Sex等这些特征非常重要</p><p>我们可以做筛选</p><pre><code class="python">model = SelectFromModel(clf, prefit=True)train_reduced = model.transform(train)print (train_reduced.shape)</code></pre><pre><code>(891, 13)</code></pre><pre><code class="python">test_reduced = model.transform(test)print (test_reduced.shape)</code></pre><pre><code>(418, 13)</code></pre><p>这里筛了13个（这个自己决定，我测试的话13个准确率比较高）</p><h2 id="看一下不同模型的表现"><a href="#看一下不同模型的表现" class="headerlink" title="看一下不同模型的表现"></a>看一下不同模型的表现</h2><pre><code class="python">logreg = LogisticRegression()logreg_cv = LogisticRegressionCV()rf = RandomForestClassifier()gboost = GradientBoostingClassifier()models = [logreg, logreg_cv, rf, gboost]</code></pre><pre><code class="python">for model in models:    print (&#39;Cross-validation of : {0}&#39;.format(model.__class__))    score = compute_score(clf=model, X=train_reduced, y=targets, scoring=&#39;accuracy&#39;)    print (&#39;CV score = {0}&#39;.format(score))    print (&#39;****&#39;)</code></pre><pre><code>Cross-validation of : &lt;class &#39;sklearn.linear_model._logistic.LogisticRegression&#39;&gt;CV score = 0.8103383340656581****Cross-validation of : &lt;class &#39;sklearn.linear_model._logistic.LogisticRegressionCV&#39;&gt;CV score = 0.8159500345238841****Cross-validation of : &lt;class &#39;sklearn.ensemble._forest.RandomForestClassifier&#39;&gt;CV score = 0.8204255853367648****Cross-validation of : &lt;class &#39;sklearn.ensemble._gb.GradientBoostingClassifier&#39;&gt;CV score = 0.8372481325717155****</code></pre><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>我在这里使用随机森林模型。它可能不是执行此任务的最佳模型，但随机森林非常方便。但是，它们确实带有一些要调整的参数，以便为预测任务获得最佳模型。</p><pre><code class="python"># 如果你想看最佳参数 就把 run_gs设置为Truerun_gs = Falseif run_gs:    parameter_grid = {                 &#39;max_depth&#39; : [4, 6, 8],                 &#39;n_estimators&#39;: [50, 10],                 &#39;max_features&#39;: [&#39;sqrt&#39;, &#39;auto&#39;, &#39;log2&#39;],                 &#39;min_samples_split&#39;: [2, 3, 10],                 &#39;min_samples_leaf&#39;: [1, 3, 10],                 &#39;bootstrap&#39;: [True, False],                 }    forest = RandomForestClassifier()    cross_validation = StratifiedKFold(n_splits=5)    grid_search = GridSearchCV(forest,                               scoring=&#39;accuracy&#39;,                               param_grid=parameter_grid,                               cv=cross_validation,                               verbose=1                              )    grid_search.fit(train, targets)    model = grid_search    parameters = grid_search.best_params_    print(&#39;Best score: {}&#39;.format(grid_search.best_score_))    print(&#39;Best parameters: {}&#39;.format(grid_search.best_params_))else:    parameters = {&#39;bootstrap&#39;: False, &#39;min_samples_leaf&#39;: 3, &#39;n_estimators&#39;: 50,                  &#39;min_samples_split&#39;: 10, &#39;max_features&#39;: &#39;sqrt&#39;, &#39;max_depth&#39;: 6}    model = RandomForestClassifier(**parameters)    model.fit(train, targets)</code></pre><p><strong>可以用模型进行预测然后上传啦！</strong></p><pre><code class="python">output = model.predict(test).astype(int)df_output = pd.DataFrame()aux = pd.read_csv(&#39;test.csv&#39;)df_output[&#39;PassengerId&#39;] = aux[&#39;PassengerId&#39;]df_output[&#39;Survived&#39;] = outputdf_output[[&#39;PassengerId&#39;,&#39;Survived&#39;]].to_csv(&#39;gridsearch_rf.csv&#39;, index=False)</code></pre><h1 id="四、Blending-（模型融合）"><a href="#四、Blending-（模型融合）" class="headerlink" title="四、Blending （模型融合）"></a>四、Blending （模型融合）</h1><pre><code class="python">trained_models = []for model in models:    model.fit(train, targets)    trained_models.append(model)predictions = []for model in trained_models:    predictions.append(model.predict_proba(test)[:, 1])predictions_df = pd.DataFrame(predictions).Tpredictions_df[&#39;out&#39;] = predictions_df.mean(axis=1)predictions_df[&#39;PassengerId&#39;] = aux[&#39;PassengerId&#39;]predictions_df[&#39;out&#39;] = predictions_df[&#39;out&#39;].map(lambda s: 1 if s &gt;= 0.5 else 0)predictions_df = predictions_df[[&#39;PassengerId&#39;, &#39;out&#39;]]predictions_df.columns = [&#39;PassengerId&#39;, &#39;Survived&#39;]</code></pre><pre><code class="python">predictions_df.to_csv(&#39;blending_base_models.csv&#39;, index=False)</code></pre><p><strong>但是模型融合的准确率并不是很高，可能别的模型没有仔细的调参。</strong><br>融合前0.79，融合后0.77（sad</p><p><strong>目前先做到这，有想法在持续跟近。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kaggle入门(Titanic案例)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-技术" scheme="http://Supltz.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="-机器学习" scheme="http://Supltz.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>初试华为云Model Arts</title>
    <link href="http://Supltz.github.io/2020/04/27/huawei.html/"/>
    <id>http://Supltz.github.io/2020/04/27/huawei.html/</id>
    <published>2020-04-27T13:47:45.000Z</published>
    <updated>2020-04-28T10:06:30.114Z</updated>
    
    <content type="html"><![CDATA[<p>使用华为云Model Arts 来做机器学习或深度学习相关项目<br><a id="more"></a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo newasdafasfsa</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="python">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="python">import waveimport pyaudiofrom PIL import ImageGrabimport numpy as npimport cv2from moviepy.editor import *from moviepy.audio.fx import allimport timefrom pydub import AudioSegmentCHUNK = 1024FORMAT = pyaudio.paInt16CHANNELS = 2RATE = 44100WAVE_OUTPUT_FILENAME = &quot;output.wav&quot;p = pyaudio.PyAudio()wf = wave.open(WAVE_OUTPUT_FILENAME, &#39;wb&#39;)wf.setnchannels(CHANNELS)wf.setsampwidth(p.get_sample_size(FORMAT))wf.setframerate(RATE)audio_record_flag = Truedef callback(in_data, frame_count, time_info, status):    wf.writeframes(in_data)    if audio_record_flag:</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用华为云Model Arts 来做机器学习或深度学习相关项目&lt;br&gt;
    
    </summary>
    
      <category term="-技术" scheme="http://Supltz.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="-机器学习 -深度学习" scheme="http://Supltz.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Thoughts</title>
    <link href="http://Supltz.github.io/2020/04/27/Thoughts_1.html/"/>
    <id>http://Supltz.github.io/2020/04/27/Thoughts_1.html/</id>
    <published>2020-04-27T13:47:45.000Z</published>
    <updated>2020-05-01T16:21:57.781Z</updated>
    
    <content type="html"><![CDATA[<p>就把它当作发牢骚的地方吧！<br><a id="more"></a></p><pre><code class="bash">说说明日方舟，炉石传说这类抽卡类的游戏吧！（两个都玩过但是都弃坑了）</code></pre><p>就根据氪金来说，在我玩过的游戏里大概分为3类：</p><ol><li>下载游戏可能要付钱，但是游戏内氪金不会太影响游戏体验的（并不会直接影响到你的游戏实力）。比如LOL，PUBG，单机游戏，独立游戏这一类的。</li><li>游戏内氪金就能获得确切的游戏体验的。比如DNF之类的。（穷，没玩过太多这类游戏）</li><li>游戏内氪金不能明确增加游戏实力，但是能增加概率的。比如上述的抽卡类游戏。</li></ol><p>相信大家都不怎么喜欢第二类游戏，当你技术比对面高，等级也差不多，但是对面氪金的装备比你好，决斗场里你一顿操作打别人一半天，别人反手一招你就GG了。心里真是（Wdnmd）氪金玩家。</p><p>在现实生活已经体验过被“氪金玩家”虐了，为何在目的为娱乐的游戏里还要受这种苦呢？（DNF富豪请自行离开）</p><p>毕竟大多数人都讨厌这种氪金就能碾压，极度破坏游戏平衡的感觉，但是游戏公司也要恰饭的呀，不能可只靠流量赚钱，所以抽卡类游戏就诞生了，他淡化了从氪金到“成功”这一绝对关系。这样子就从<strong>穷玩家</strong>—&gt;<strong>氪金玩家</strong>变成了，<strong>穷玩家，非酋</strong>—&gt;<strong>氪金玩家，欧皇</strong>，表面上看起来挺好的，氪金也不一定能比得过“欧皇”，但是其实，实质上这个游戏的上限并没有改变，因为在氪金能增加概率的情况下，只要你氪金够多，你就能超越欧皇站在这个游戏的顶端！</p><p>所以不如把第三类游戏和第二类游戏归为一类，你会发现他两加起来玩家的人数都不比第一类的任何一个游戏玩家的人数多，毕竟大家玩游戏只是为了娱乐，玩家与玩家之间应该通过技术来进行对比和比拼，而不是通过金钱。</p><p>我既不想在这类游戏里被氪金玩家所嘲讽碾压（除非你是超级欧皇），我的价值观也一直觉得往游戏里充值是虚无的是空虚的优越感，所以第二类第三类的游戏我都弃游了，游戏本身也许是好游戏，只是这个奖励机制实在令人诟病罢了。</p><p><strong>还是建议大家去玩第一类游戏吧！</strong></p><p>因为对我来讲，游戏最多还是一种社交工具的存在，最好是要第一类中的多人在线组队类的，比如LOL和PUBG等。你在娱乐的同时，也与朋友同学增进了感情（技术好说不定还受人钦佩，何乐而不为呢？）</p><p>我是觉得人总是要和别人交流的，虽然独立游戏，单机游戏制作精良（实际上这两类才是顶级游戏），但缺少了人与人的交流。不过这个还是看个人价值观啦（有很多独立音乐人虽然没流行音乐人混的好，不也很受人敬佩的不是吗？）</p><p>这里讨论到了流行与独立。。。。。。（<em>未完待续</em>）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就把它当作发牢骚的地方吧！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-杂谈" scheme="http://Supltz.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="-感悟" scheme="http://Supltz.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发入门</title>
    <link href="http://Supltz.github.io/2020/04/27/Android.html/"/>
    <id>http://Supltz.github.io/2020/04/27/Android.html/</id>
    <published>2020-04-27T13:47:45.000Z</published>
    <updated>2020-04-28T10:06:45.822Z</updated>
    
    <content type="html"><![CDATA[<p>Android入门<br><a id="more"></a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo newasdafasfsa</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android入门&lt;br&gt;
    
    </summary>
    
      <category term="-技术" scheme="http://Supltz.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="-Android" scheme="http://Supltz.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://Supltz.github.io/2020/04/27/python.html/"/>
    <id>http://Supltz.github.io/2020/04/27/python.html/</id>
    <published>2020-04-27T13:47:45.000Z</published>
    <updated>2020-05-10T15:26:08.632Z</updated>
    
    <content type="html"><![CDATA[<p>就是最近用python总结得一些坑和经验啦（其实基础还是有点不扎实，还需要买本书啃一啃<br><a id="more"></a></p><h2 id="最近用python写作业遇到的一些小坑"><a href="#最近用python写作业遇到的一些小坑" class="headerlink" title="最近用python写作业遇到的一些小坑"></a>最近用python写作业遇到的一些小坑</h2><h3 id="pip-安装卡顿（time-out问题）"><a href="#pip-安装卡顿（time-out问题）" class="headerlink" title="pip 安装卡顿（time out问题）"></a>pip 安装卡顿（time out问题）</h3><pre><code class="python">pip install -i https://pypi.douban.com/simple （package）      #使用豆瓣的镜像pip install --index-url https://pypi.tuna.tsinghua.edu.cn/simple –upgrade （package）      #使用清华大学的镜像</code></pre><h3 id="python中的切片"><a href="#python中的切片" class="headerlink" title="python中的切片"></a>python中的切片</h3><pre><code class="python">[a:b:c]# a是索引起点，b是终点，c是步长    ！！！重点python的切片都是左闭右开的[a:b)</code></pre><h3 id="opencv读图片的问题"><a href="#opencv读图片的问题" class="headerlink" title="opencv读图片的问题"></a>opencv读图片的问题</h3><pre><code class="python">#中文目录的话用imread方法会出现问题。#解决方案：def readimg(filename, mode):    raw_data = np.fromfile(filename, dtype=np.uint8)  #先用numpy把图片文件存入内存：raw_data，把图片数据看做是纯字节数据    img = cv2.imdecode(raw_data, mode)  #从内存数据读入图片，mode可以是cv2.IMREAD_COLOR（表示彩色图片，读进来三个通道）    return img#opencv读进来的是[宽,高,通道数]</code></pre><h3 id="python读文件夹的问题"><a href="#python读文件夹的问题" class="headerlink" title="python读文件夹的问题"></a>python读文件夹的问题</h3><pre><code class="python">for filename in os.listdir(directory):#   code here#   code here#这里的filename列表不一定和你文件夹里的文件顺序一样（可以改命名转为int来进行排序）</code></pre><p><em>以后遇到python相关的问题还会在这里持续更新的！</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就是最近用python总结得一些坑和经验啦（其实基础还是有点不扎实，还需要买本书啃一啃&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-技术" scheme="http://Supltz.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="-python" scheme="http://Supltz.github.io/tags/python/"/>
    
  </entry>
  
</feed>
